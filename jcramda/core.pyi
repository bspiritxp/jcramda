from typing import (
    Callable, Any, Union, TypeVar, Iterable, Sequence, Tuple,
    Optional, List, DefaultDict, overload, TypeAlias, Type
    )

T = TypeVar('T')
KT = TypeVar('KT')
VT = TypeVar('VT')
RT = TypeVar('RT')

OT = TypeAlias(Optional[T])

"""
Curry
"""
from inspect import Parameter

EmptyParam: Parameter.empty

def curry(fn: Callable) -> Callable: ...
def is_curried(f: Callable) -> bool: ...
def flip(f: Callable) -> Callable: ...

def compose(*fns: Callable) -> Callable: ...
co = compose

def pipe(*funcs: Callable) -> Callable: ...


"""
IterTools
"""
# chain((1, 2, 3), [4, 5, (6, 7)]) -> (1, 2, 3, 4, 5, 6, 7)
# chain(append, first)([1, 2, 3]) -> (1, 2, 3, 1)
@overload
def chain(*funcs: Callable) -> Callable[[Iterable[VT]], Tuple[VT]]: ...

@overload
def chain(*iterable: Iterable[VT]) -> Tuple[VT]: ...

@overload
def chain(*funcs: Callable, iterable: Iterable[VT] = ...): ...


# combine(range(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)
def combine(seqs: Iterable[Iterable], r: int = ...) -> Union[Tuple[Tuple], Callable]: ...


def count(f: Callable[[int], Any],
          end: Union[int, Callable[[int, Any], bool]],
          start: int = 0, step: int = 1): ...


def filter_(f: Callable[[], bool], iterable: Iterable): ...

def filter_not(f: Callable[[], bool], iterable: Iterable): ...

def filter_except(f: Callable[[], bool], exceptions: Iterable[Exception],
                  iterable: Iterable): ...

def first(iterable: Iterable[VT]) -> VT: ...

def flatten(*iterable: Iterable) -> Tuple: ...

@overload
def fmap(f: Callable[[], VT], iterable: Iterable[VT]) -> Iterable[VT]: ...

@overload
def fmap(f: Callable[[], VT]) -> Callable[[Iterable[VT]], Iterable[RT]]: ...

@overload
def fmapof(f: Callable[[], VT], iterable: Iterable[VT]) -> Tuple[VT]: ...

@overload
def fmapof(f: Callable[[], VT]) -> Callable[[Iterable[VT]], Tuple[RT]]: ...

def fold(f: Callable[[RT, VT], RT], init: RT, iterable: Iterable[VT]) -> RT: ...

def foreach(f: Callable, iterable: Iterable[VT] = ...,
            chunk_size: Optional[int] = None, before: Optional[Callable] = None,
            after: Optional[Callable] = None) \
        -> Union[Iterable[VT], Callable[[Any], Iterable[VT]]]: ...

def groupby(f: Callable[[VT], KT], iterable: Iterable[VT]) \
    -> Iterable[Tuple[KT, Iterable[VT]]]: ...

def ireplace(f: Callable[[], bool], sub: RT, iterable: Iterable[VT],
             _count: Optional[int] = ..., window_size: int = 1) -> Iterable[Union[VT, RT]]: ...

# functional of slice: iterable[1::2]
def islice(rng: Union[int, tuple], iterable: Iterable[VT]) -> Iterable[VT]: ...

def last(iterable: Iterable[VT]) -> VT: ...

def map_(f: Callable[[VT], RT], *iterable: Iterable[VT]) -> Iterable[RT]: ...

def mapof(f: Callable[[VT], RT], *iterable: Iterable[VT]) -> Tuple[RT]: ...

def map_except(f: Callable[[VT], RT], exceptions: Iterable[Exception],
               iterable: Iterable[VT]) -> Iterable[RT]: ...

def map_reduce(key: Callable[[VT], KT], iterable: Iterable[VT],
               emit: Optional[Callable[[VT], RT]],
               reducer: Optional[Callable[[Tuple[RT]], T]]
               ) -> DefaultDict[KT, List[Union[RT, T]]]: ...

def of(*iterable: Union[Iterable[VT], VT],
       cls=Callable[[Iterable[VT]], Sequence[VT]]): ...

def one(iterable: Iterable[VT]) -> Union[Tuple[VT], VT]: ...
# 排列
def permute(iterable: Iterable[VT], r: int) -> Iterable[Tuple[VT]]: ...

# product((1,2), (3,4)) -> (1, 3), (1, 4), (2, 3), (2, 4)
def product(*iterable: Iterable[VT], r: int = 1) -> Iterable[Tuple[VT]]: ...

def product_map(f: Callable[[VT], RT], *iterable: Iterable[VT]) -> Iterable[RT]: ...

# repeat(3, 1) -> (1, 1, 1)
# repeat(None, 'x') -> ('x', 'x', 'x', .... ) // endless
def repeat(n: int, x: T) -> Iterable[T]: ...

def scan(f: Callable[[RT, VT], RT], init: RT,
         iterable: Iterable[VT]) -> Iterable[RT]: ...

# >>> select([1, 0, 1, 1, 0], range(1, 6)) -> iter(1, 3, 4)
def select(selector: Iterable[Union[bool, int]], iterable: Iterable): ...

def zip_(fill_value: VT, *iterable: Iterable) -> Iterable[Tuple]: ...


"""
Operator
"""

def eq(a: OT, b: OT = ...) -> Union[Callable[[OT], bool], bool]: ...
def ne(a: OT, b: OT = ...) -> Union[Callable[[OT], bool], bool]: ...
def lt(a: T, b: T = ...) -> Union[Callable[[T], bool], bool]: ...
def le(a: T, b: T = ...) -> Union[Callable[[T], bool], bool]: ...
def ge(a: T, b: T = ...) -> Union[Callable[[T], bool], bool]: ...
def gt(a: T, b: T = ...) -> Union[Callable[[T], bool], bool]: ...
def eq_by(f: Callable[[T, T], bool], a: T = ..., b: T = ...) -> Union[Callable, bool]: ...

def cmp_range(rng: range, v: int = ...) -> Union[Callable[[int], int], int]: ...
def between(_min: T, _max: T = ..., v: T = ...) -> Union[Callable, bool]: ...
def clamp(_min: T, _max: T = ..., v: T = ...) -> Union[Callable, T]: ...
def not_(o: T) -> bool: ...
def truth(o: T) -> bool: ...
def is_(a: OT, b: OT = ...) -> Union[Callable[[OT], bool], bool]: ...
def is_not(a: OT, b: OT = ...) -> Union[Callable[[OT], bool], bool]: ...
def is_a(types: Union[Tuple[Type], Type, None], o: T = ...) -> Union[Callable[[T], bool], bool]: ...
def not_a(types: Union[Tuple[Type], Type, None], o: T = ...) -> Union[Callable[[T], bool], bool]: ...
def is_none(o: OT) -> bool: ...
def not_none(o: OT) -> bool: ...
def and_(a: Any, b: Any = ...) -> bool: ...
def or_(a: Any, b: Any = ...) -> bool: ...

def add(a: T, b: T) -> T: ...
# sub: b - a
def sub(a: T, b: T) -> T: ...
# dec:
def dec(a: int) -> int: ...
inc: Any
floordiv: Any
div: Any
inv = _op.inv
lshift: Any
mod: Any
mul: Any
matmul: Any
neg = _op.neg
pos = _op.pos
pow_: Any
xor: Any

def concat(a: Any, b: Any, *args: Any): ...

in_: Any
not_in: Any
countof: Any
delitem: Any
getitem: Any
setitem: Any
attr: Any
props: Any
bind = _op.methodcaller

def index(x: Any, xs: Any, start: int = ..., end: Optional[Any] = ...): ...
def indexall(x: Any, xs: Any, start: int = ..., end: Optional[Any] = ...): ...
def identity(f: Any, *args: Any, **kw: Any): ...
def when(*cases: Iterable[Tuple[Callable, Any]], else_: Any=...) -> Any: ...
def case(cases: dict, v: Any, default: Any=...) -> Any: ...
def always(x: Any, _: Any): ...
def if_else(p: Iterable[Callable], value: Any) -> Any: ...
def all_(funcs: Iterable[Callable[[Any], bool]], v: Any) -> Any: ...
def any_(funcs: Iterable[Callable[[Any], bool]], v: Any) -> Any: ...
def default_to(df: Any, raw: Any): ...
def import_(module_name: Any, package: Optional[Any] = ...): ...
def from_import_as(_name: Any, from_module: Any, package: Optional[Any] = ...): ...
def eq_attr(attr_name: Any, o1: Any, o2: Any): ...
def eq_prop(prop_name: Any, s1: Any, s2: Any): ...
def has_attr(attr_name: Any, obj: Any): ...


